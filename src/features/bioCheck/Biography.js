/*
The MIT License (MIT)

Copyright (c) 2022 Kathryn J Knight

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 * Parse and validate a WikiTree biography
 * Gather information about style and the parts needed to validate
 * along with information about the bio and methods to parse and validate
 */
import { BiographyResults } from "./BiographyResults.js"
export class Biography extends BiographyResults {

  sourceRules = null;             // rules for testing sources
  bioLines = ([]);                // lines in the biography
  bioHeadingsFound = [];          // biography headings found (multi lang)
  sourcesHeadingsFound = [];      // sources headings found (multi lang)
  invalidSpanTargetList = ([]);   // target of a span that are not valid
  refStringList = ([]);           // all the <ref> this </ref> lines
  namedRefStringList = ([]);      // all the <ref> with names

  bioInputString = "";            // input string may be modified by processing
  biographyIndex = -1;            // first line of biography
  acknowledgementsEndIndex = -1;  // next heading or end of bio
  sourcesIndex = -1;              // first line of sources
  referencesIndex = -1;           // index into vector for <references tag
  acknowledgementsIndex = -1;     // first line of acknowledgements
  researchNotesIndex = -1;        // first line of researchNotes
  researchNotesEndIndex = -1;     // last line of research notes is next heading

  isPre1700 = false;              // is this a pre1700 profile
  isPre1500 = false;              // is this a pre1500 profile
  tooOldToRemember = false;       // is this profile to old to remember
  treatAsPre1700 = false;         // treat all profiles as pre1700

  static START_OF_COMMENT = "<!--";
  static END_OF_COMMENT = "-->";
  static START_OF_BR = "<br";
  static REF_START = "<ref>";
  static REF_END = "</ref>";
  static END_BRACKET = ">";
  static REF_START_NAMED = "<ref name";
  static REF_END_NAMED = "/>";
  static HEADING_START = "==";
  static CATEGORY_START = "[[category";
  static REFERENCES_TAG = "<references";
  static UNSOURCED = "unsourced";
  static UNSOURCED_TAG = "{{unsourced";
  static UNSOURCED_TAG2 = "{{ unsourced";
  static QUESTIONABLE_TAG = "{{template:questionable";
  static UNCERTAIN_TAG = "{{uncertain existence";
  static DISPROVEN_TAG = "{{disproven existence";
  static DISPROVEN2_TAG = "{{disproven existence project";
  static AUTO_GENERATED = "auto-generated by a gedcom import";
  static SPAN_TARGET_START = "<span id=";
  static SPAN_TARGET_END = "</span>";
  static SPAN_REFERENCE_START = "[[#";
  static SPAN_REFERENCE_END = "]]";
  static MIN_SOURCE_LEN = 15;       // minimum length for valid source
  static SOURCE_START = "source:";
  static SEE_ALSO = "see also";

  /**
   * Constructor
   * @param sourceRules source rules for validating sources
   * @param bioResults container for BiographyResults
   */ 
  constructor(theSourceRules) {
    super();
     this.sourceRules = theSourceRules;
  }

  /**
   * Parse contents of the bio
   * @param inStr bio string as returned from server
   * @param isPre1500 true if profile is treated as Pre1500
   * @param isPre1700 true if profile is treated as Pre1700
   * @param mustBeOpen true if profile is treated as too old to remember
   * @param bioUndated true if profile has no dates
   * @param checkAutoGenerated true to report profiles with auto-generated * string
   * Side effects - set statistics and style
   */
  parse(inStr, isPre1500, isPre1700, mustBeOpen, bioUndated, checkAutoGenerated) {
    this.isPre1500 = isPre1500;
    this.isPre1700 = isPre1700;
    this.tooOldToRemember = mustBeOpen;
    this.bioResults.stats.bioIsUndated = bioUndated;

    this.bioInputString = inStr;
    // Check for empty bio
    if (this.bioInputString.length === 0) {
      this.bioResults.stats.bioIsEmpty = true;
      this.bioResults.style.bioHasStyleIssues = true;
      return;
    }
    // check for endless comment
    this.bioInputString = this.swallowComments(this.bioInputString);
    if (this.bioResults.style.hasEndlessComment) {
      this.bioResults.style.bioHasStyleIssues = true;
      return;
    }
    // assume no style issues
    this.bioResults.style.bioHasStyleIssues = false;

    // swallow any <br>
    this.bioInputString = this.swallowBr(this.bioInputString);

    // if auto generated from GEDCOM and testing this, report as style issue
    if (checkAutoGenerated) {
      let tmpLine = this.bioInputString.toLowerCase();
      if ((tmpLine.indexOf(Biography.AUTO_GENERATED)) > 0) {
        this.bioResults.style.bioHasStyleIssues = true;
        this.bioResults.style.bioIsAutoGenerated = true;
      }
    }

    // build a vector of each line in the bio then iterate
    this.getLines(this.bioInputString);
    let lineCount = this.bioLines.length;
    let currentIndex = 0;
    while (currentIndex < lineCount) {
      let line = this.bioLines[currentIndex].toLowerCase();
      // handle the case where there is no space before ending /
      // so it might start with a blank
      // TODO maybe report starting with a blank as a style issue?
      if (line.indexOf(Biography.REFERENCES_TAG) >= 0) {
        this.referencesIndex = currentIndex;
      } else {
        if (line.startsWith(Biography.CATEGORY_START)) {
          this.bioResults.stats.bioHasCategories = true;
          if (line.includes(Biography.UNSOURCED)) {
            this.bioResults.stats.bioIsMarkedUnsourced = true;
          }
        } else {
          if (line.startsWith(Biography.HEADING_START)) {
            this.evaluateHeadingLine(line, currentIndex);
          }       // end if a heading line
        }         // end if a category line
      }           // end if references tag
      currentIndex++;
    }
    // acknowlegements may go to end of bio
    if (this.acknowledgementsEndIndex < 0) {
      this.acknowledgementsEndIndex = lineCount;
    }
    let line = this.bioInputString.toLowerCase();
    if ((line.includes(Biography.UNSOURCED_TAG)) ||
          (line.includes(Biography.UNSOURCED_TAG2))) {
      this.bioResults.stats.bioIsMarkedUnsourced = true;
    }
    if (line.includes(Biography.QUESTIONABLE_TAG) ||
         (line.includes(Biography.UNCERTAIN_TAG)) ||
         (line.includes(Biography.DISPROVEN2_TAG)) ||
         (line.includes(Biography.DISPROVEN_TAG))) {
         this.bioResults.stats.bioIsUncertainExistance = true;
    }

    // Get the string that might contain <ref>xxx</ref> pairs
    let bioLineString = this.getBioLineString();
    this.findRef(bioLineString);
    this.findNamedRef(bioLineString);

    this.setBioStatisticsAndStyle();

    // Lose bio lines not considered to contain sources
    this.removeResearchNotes();
    this.removeAcknowledgements();

    if (this.bioResults.style.bioHasRefWithoutEnd) {
      this.bioResults.style.bioHasStyleIssues = true;
    }
    return;
  }

  /**
   * Validate contents of bio
   * @return true if probably valid sources and no style issues, else false
   */
  validate() {

    let isValid = false;
    /*
     * Don't bother for empty bio, one already marked unsourced, uncertain existance
     * or the manager's own profile
     */
    if (!this.bioResults.stats.bioIsEmpty && 
        !this.bioResults.stats.bioIsMarkedUnsourced &&
        !this.bioResults.stats.bioIsUncertainExistance &&
        !this.bioResults.stats.bioIsUndated) {
      // Look for a partial string that makes it valid
      isValid = this.sourceRules.containsValidPartialSource(this.bioInputString.toLowerCase());

      /*
       * First validate strings after references. This will build a side effect of
       * a list of invalid span tags.
       * Next validate strings between Sources and <references />. This will update/build
       * a side effect list of invalid span tags.
       * Finally validate the references, looking at invalid span tags if needed.
       *
       * Strings after references and within named and unnamed ref tags are
       * validated to add those to the list of valid/invalid sources
       */
      if (!isValid) {
        isValid = this.validateReferenceStrings(true);
        if (this.validateRefStrings(this.refStringList)) {
          if (!isValid) {
            isValid = true;
          }
        }
        if (this.validateRefStrings(this.namedRefStringList)) {
          if (!isValid) {
            isValid = true;
          }
        }
        if (!isValid) {
          this.bioResults.sources.sourcesFound = false;
          isValid = false;
        }
      }
    }
    if (isValid) {
      this.bioResults.sources.sourcesFound = true;
    }
    return isValid;
  }

  /**
   * Validate contents Sources for adding a new profile
   * @param sourcesStr string containing sources
   * @param isPre1500 true if profile is treated as Pre1500
   * @param isPre1700 true if profile is treated as Pre1700
   * @param mustBeOpen true if profile is treated as too old to remember
   * @return true if probably valid sources, else false
   */
  validateSourcesStr(sourcesStr, isPre1500, isPre1700, mustBeOpen) {

    // build bioLines from the input sources string then validate
    this.getLines(sourcesStr);
    this.isPre1500 = isPre1500;
    this.isPre1700 = isPre1700;
    this.tooOldToRemember = mustBeOpen;
    let isValid = this.validateReferenceStrings(false);
    return isValid;
  }

  /* *********************************************************************
   * ******************* PRIVATE METHODS *********************************
   * ******************* used by Parser **********************************
   * *********************************************************************
   */

  /*
   * Swallow comments
   * side effect set style if endless comment found
   * @param inStr
   * @return string with comments removed
  */
  swallowComments(inStr) {
    let outStr = "";
    /*
     * Find start of comment
     * Put everything before start in output string
     * Find end of comment, skip past the ending and start looking there
    */
    let pos = 0;               // starting position of the comment
    let endPos = 0;            // end position of the comment
    let len = inStr.length;    // length of input string
    pos = inStr.indexOf(Biography.START_OF_COMMENT);
    if (pos < 0) {
      outStr = inStr;         // no comments
    }
    while ((pos < len) && (pos >= 0)) {
      // get everything to start of comment unless comment is first line in bio
      if (pos > 0) {
        outStr = outStr + inStr.substring(endPos, pos - 1);
      }
      // Find end of comment
      endPos = inStr.indexOf(Biography.END_OF_COMMENT, pos);
      if (endPos > 0) {
        pos = endPos + 3;    // skip the --> and move starting position there
        if (pos <= len) {
          pos = inStr.indexOf(Biography.START_OF_COMMENT, pos);  // find next comment
          if (pos < 1) {
            outStr += inStr.substring(endPos + 3);
          }
        }
      } else {
        this.bioResults.style.hasEndlessComment = true;
        pos = inStr.length + 1;  // its an endless comment, just bail
      }
    }
    return outStr;
  }
  /* 
   * Swallow BR 
   * could be in the form <br> or <br/> or <br />
   * @param inStr
   * @return string with br removed
   */
  swallowBr(inStr) {
    let outStr = "";
    let pos = 0;
    let endPos = 0;
    let len = inStr.length;
    pos = inStr.indexOf(Biography.START_OF_BR);
    if (pos < 0) {
       outStr = inStr;         // no br
    } 
    while ((pos < len) && (pos >= 0)) {
      if (pos > 0) {
        outStr = outStr + inStr.substring(endPos, pos);
      }
      endPos = inStr.indexOf(Biography.END_BRACKET, pos);
      if (endPos > 0) {
        pos = endPos + 1;    // skip the /> and move starting position there
        if (pos <= len) {
          pos = inStr.indexOf(Biography.START_OF_BR, pos);  // find next comment
          if (pos < 1) {
            outStr += inStr.substring(endPos + 1);
          }
        }
      }
    }
    return outStr;
  }

  /*
   * Build an array of each line in the bio
   * lines are delimited by a newline
   * empty lines or those with only whitespace are eliminated
   * @param inStr bio string stripped of comments
   */
  getLines(inStr) {
    let splitString = inStr.split("\n");
    let line = "";
    let tmpString = "";
    let len = splitString.length;
    for (let i = 0; i < len; i++) {
      line = splitString[i];
      // line is nothing but ---- ignore it by replacing with spaces then
      // trimming
      tmpString = line.replace('-', ' ');
      tmpString = tmpString.trim();
      // Sanity check if the line with <references /> also has text following on same line
      if (tmpString.indexOf(Biography.REFERENCES_TAG) >= 0) {
        let endOfReferencesTag = tmpString.indexOf(Biography.END_BRACKET);
        if (endOfReferencesTag + 1 < tmpString.length) {
          // Oopsie. Add a line for references and another for the line
          // and report a style issue?
          let anotherLine = tmpString.substring(0, endOfReferencesTag + 1);
          this.bioLines.push(anotherLine);
          line = tmpString.substring(endOfReferencesTag + 2);
          if (!line.length === 0) {
            this.bioLines.push(tmpString);
          }
        } else {
          this.bioLines.push(tmpString);
        }
      } else {
        this.bioLines.push(line);
      }
    }
    return;
  }

  /* 
   * Process heading line to find Biography, Sources, Acknowledgements
   * set index to each section
   * Methods are used to find sections so that rules can specify 
   * alternate languages
   * @param inStr starting with ==
   * @param currentIndex into master list of strings
   */
  evaluateHeadingLine(inStr, currentIndex) {

    let headingText = "";
    let headingStartPos = 0;
    let headingLevel = 0;
    /*
     * the bioLineString should start with the larger of the start of the line
     * after the biography heading or 0
     * it should end with the smallest of the length of the bio string or
     * the first heading found after the biography heading
    */
    let len = inStr.length;
    while ((headingStartPos < len) && (headingLevel < 4)) {
      if (inStr.charAt(headingStartPos) === '=') {
        headingStartPos++;
        headingLevel++;                // number of =
      } else {
        // lose any leading ' for bold or italics
        let i = headingLevel;
        while ((i < len) && (inStr.charAt(i) === "'")) {
          i++;
        }
        headingStartPos = len + 1;       // break out of loop

        // then lose anything after the next =
        headingText = (inStr.substring(i)).trim();
        let j = headingText.indexOf('=');
        if (j < 0) {
          j = headingText.length;
        }
        headingText = (headingText.substring(0,j)).trim();
      }
    }
    // Save index for this heading   
    if (this.isBiographyHeading(headingText)) {
      if (this.biographyIndex < 0) {
        this.biographyIndex = currentIndex;
      } else {
        if (this.researchNotesIndex > 0) {
          this.researchNotesEndIndex = currentIndex - 1;
        }
      }
    } else {
      if (this.sourceRules.isResearchNotesHeading(headingText)) {
        this.researchNotesIndex = currentIndex;
      } else {
        if (this.isSourcesHeading(headingText)) {
          if (headingLevel > 2) {
              this.bioResults.style.sourcesHeadingHasExtraEqual = true;
              this.bioResults.style.bioHasStyleIssues = true;
          }
          if (this.sourcesIndex < 0) {
            this.sourcesIndex = currentIndex;
            if (this.researchNotesIndex > 0) {
              this.researchNotesEndIndex = currentIndex - 1;
            }
            if (this.acknowledgementsIndex > 0) {
              this.acknowledgementsEndIndex = currentIndex - 1;
            }
          } else {
              //this.bioResults.style.bioHasMultipleSourceHeadings = true;
              //this.bioResults.style.bioHasStyleIssues = true;
          }
        } else {
          if (this.sourceRules.isAckHeading(headingText)) {
            if (headingLevel > 2) {
              this.bioResults.style.acknowledgementsHeadingHasExtraEqual = true;
              this.bioResults.style.bioHasStyleIssues = true;
            }
            if (this.sourcesIndex < 0) {
              this.bioResults.style.bioHasAcknowledgementsBeforeSources = true;
              this.bioResults.style.bioHasStyleIssues = true;
            }
            this.acknowledgementsIndex = currentIndex;
            if ((this.researchNotesIndex > 0) && (this.researchNotesEndIndex < 0)) {
               this.researchNotesEndIndex = currentIndex - 1;
            }
          } else {
            // TODO if this is before biography, add a style issue Heading
            // before Biography (aka biographyIndex < 0)
            // just a line
          } // endif Acknowledgements
        } // endif Sources
      } // endif Research Notes
    } // endif Biography
    return;
  }

  /*
   * Get string from bio to be searched for any inline <ref
   * the bioLineString should start with the beginning of the biography
   * or the line after the Biography heading whichever is last
   * it should end with the smallest of the length of the bio string or
   * the first heading found after the biography heading
   */
  getBioLineString() {

    let bioLinesString = "";
    let startIndex = 0;
    // Jump to the start of == Biography
    if (this.biographyIndex > 0 ) {
        startIndex = this.biographyIndex;
    }
    // assume it ends at end of bio then pick smallest
    // of Research Notes, Sources, references, acknowledgements
    // which is also after the start of the biography
    let endIndex = this.bioLines.length;
    if ((this.researchNotesIndex > 0) && (this.researchNotesIndex > startIndex)) {
      endIndex = this.researchNotesIndex;
    }
    if ((this.sourcesIndex > 0) && (this.sourcesIndex < endIndex)) {
      endIndex = this.sourcesIndex;
    }
    if ((this.referencesIndex > 0) &&
        (this.referencesIndex < endIndex)) {
      endIndex = this.referencesIndex;
    }
    if ((this.acknowledgementsIndex > 0) &&
        (this.acknowledgementsIndex < endIndex)) {
      endIndex = this.acknowledgementsIndex;
    }

    if (this.biographyIndex === endIndex) {
      this.bioResults.style.bioHeadingWithNoLinesFollowing = true;
      this.bioResults.style.bioHasStyleIssues = true;
    } else {
      if (endIndex >= 0) {
        while (startIndex < endIndex) {
          bioLinesString += this.bioLines[startIndex];
          startIndex++;
        }
      }
    }
    return bioLinesString;
  }

  /* 
   * Find <ref> </ref> pairs that don't have a name
   * @param bioLineString string to look in for pairs
   * adds contents of ref to refStringList
   */
  findRef(bioLineString) {

    let startOfRef = bioLineString.indexOf(Biography.REF_START);
    let endOfRef = bioLineString.indexOf(Biography.REF_END, startOfRef);     
    while ((startOfRef >= 0) && (!this.bioResults.style.bioHasRefWithoutEnd)) {
      if (endOfRef < 0) {
        // Oopsie, starting <ref> without an ending >
        this.bioResults.style.bioHasRefWithoutEnd = true;
        this.bioResults.style.bioHasStyleIssues = true;
      } else {
        // Now we should have the whole ref lose the <ref> and move past it
        if ((startOfRef + 5) < endOfRef) {
          startOfRef = startOfRef + 5;
        }
        let line = bioLineString.substring(startOfRef, endOfRef);
        this.refStringList.push(line);
        endOfRef++;
        if (endOfRef < bioLineString.length) {
          startOfRef = bioLineString.indexOf(Biography.REF_START, endOfRef);
          if (startOfRef > 0) {
            endOfRef = bioLineString.indexOf(Biography.REF_END, startOfRef);
          }
        }
      }
    }
    return;
  }

  /* 
   * Find named ref
   * which are pairs in the form <ref name= ></ref>
   * or in the form <ref name=xxxx />
   * @param bioLineString string to look in for pairs
   * adds contents of ref to namedRefStringList
   */
  findNamedRef(bioLineString) {

    let endOfRefNamed = -1;
    let endOfRef = -1;
    let end = -1;
    let bioLength = bioLineString.length;
    let startOfRef = bioLineString.indexOf(Biography.REF_START_NAMED);
    while (startOfRef >= 0) {
      endOfRef = bioLineString.indexOf(Biography.REF_END, startOfRef);
      endOfRefNamed = bioLineString.indexOf(Biography.REF_END_NAMED, startOfRef);
      if (endOfRef < 0) {
        endOfRef = bioLength;
      }
      if (endOfRefNamed < 0) {
        endOfRefNamed = bioLength;
      }
      // lose the <ref> portion and use first ending found
      if ((startOfRef + 5) < endOfRef) {
        startOfRef = startOfRef + 5;
      }
      end = endOfRef;
      if (endOfRef > endOfRefNamed) {
        end = endOfRefNamed;
      }
      // save just the part of the line after the name
      let line = bioLineString.substring(startOfRef, end);
      let refStart = line.indexOf(Biography.END_BRACKET);
      if (refStart > 0) {
        refStart++;
        this.namedRefStringList.push(line.substring(refStart));
      }

      // move past the ref
      end++;
      endOfRef++;
      if (end <= bioLength) {
        startOfRef = bioLineString.indexOf(Biography.REF_START_NAMED, end);
      } else {
        if (end > bioLength) {
          startOfRef = -1;        // we are done
        }
      }
    }
  }

  /*
   * Gather bio statistics and style issues
   * only examines items not considered in the parsing
   * Basic checks for the headings and content expected in the biography
   * Update results style
   */
  setBioStatisticsAndStyle() {
    this.bioResults.stats.totalBioLines = this.bioLines.length;
    if ((this.biographyIndex > 1) && !this.bioResults.stats.bioHasCategories) {
      this.bioResults.style.bioHasNonCategoryTestBeforeBiographyHeading = true;      // NOT a style issue
    }
    if (this.biographyIndex < 0) {
      this.bioResults.style.bioHasStyleIssues = true;
      this.bioResults.style.bioIsMissingBiographyHeading = true;
    }
    if (this.sourcesIndex < 0) {
      this.bioResults.style.bioHasStyleIssues = true;
      this.bioResults.style.bioIsMissingSourcesHeading = true;
    }
    if (this.referencesIndex < 0) {
      this.bioResults.style.bioHasStyleIssues = true;
      this.bioResults.style.bioIsMissingReferencesTag = true;
    }
    if (this.bioResults.style.bioHasMultipleReferencesTags) {
      this.bioResults.style.bioHasStyleIssues = true;
    }
    if (this.bioResults.style.misplacedLineCount < 0) {
      this.bioResults.style.misplacedLineCount = 0;
    }
    if (this.bioResults.style.misplacedLineCount > 0) {
      this.bioResults.style.bioHasStyleIssues = true;
    }
    this.bioResults.stats.inlineReferencesCount =
         this.refStringList.length + this.namedRefStringList.length;

    this.bioResults.stats.possibleSourcesLineCount = this.acknowledgementsIndex - 1;
    if (this.bioResults.stats.possibleSourcesLineCount < 0) {
      this.bioResults.stats.possibleSourcesLineCount = this.bioLines.length;
    }
    this.bioResults.stats.possibleSourcesLineCount = this.bioResults.stats.possibleSourcesLineCount -
    this.referencesIndex + 1 + this.bioResults.style.misplacedLineCount;
    if (this.bioResults.style.bioHasAcknowledgementsBeforeSources) {
      this.bioResults.style.bioHasStyleIssues = true;
    }
  }

  /*
   * Determine if Biography heading
   * Uses rules to check for multiple languages
   * Adds bio headings to array of bio headings found
   * @param line to test
   * @return true if biography heading else false
   */
  isBiographyHeading(line) {
    let isBioHeading = this.sourceRules.isBiographyHeading(line);
    if (isBioHeading) {
      if (this.bioHeadingsFound.includes(line)) {
        this.bioResults.style.bioHasStyleIssues = true;
        this.bioResults.style.bioHasMultipleBioHeadings = true;
      } else {
        this.bioHeadingsFound.push(line);
      }
    }
    return isBioHeading;
  }

  /*
   * Determine if Sources heading
   * Uses rules to check for multiple languages
   * Adds sources headings to array of sources headings found
   * @param line to test
   * @return true if sources heading else false
   */
  isSourcesHeading(line) {
    
    let isSourcesHeading = this.sourceRules.isSourcesHeading(line);
    if (isSourcesHeading) {
      if (this.sourcesHeadingsFound.includes(line)) {
        this.bioResults.style.bioHasStyleIssues = true;
        this.bioResults.style.bioHasMultipleSourceHeadings = true;
      } else {
        this.sourcesHeadingsFound.push(line);
      }
    }
    return isSourcesHeading;
  }

  /*
   * Remove Research Notes from bio lines
   * Remove lines between start of Research Notes
   * and end of Research Notes
   * Any content of Research Notes is not considered
   * as a source
   * Research Notes end when a Biography heading is found
   * or at the first Sources or Acknowledgements heading
   */
  removeResearchNotes() {
    let i = this.researchNotesIndex;
    let endIndex = this.researchNotesEndIndex;
    if (endIndex < 0) {
      endIndex = this.bioLines.length;
    }
    if (i > 0) {
      while (i <= endIndex) {
        this.bioLines[i] = "";
        i++;
      }
    }
  }

  /*
   * Remove acknowledgements from bio lines
   * Remove lines between start of Acknowledgements
   * and end of Acknowledgements
   * Any content of Acknowledgements is not considered
   * as a source
   * Acknowledgements end when a heading is found
   * or at the end of the biography
   */
  removeAcknowledgements() {
    let i = this.acknowledgementsIndex;
    let endIndex = this.acknowledgementsEndIndex;
    if (endIndex < 0) {
         endIndex = this.bioLines.length;
    }
    if (i > 0) {
      while (i <= endIndex) {
        this.bioLines[i] = "";
        i++;
      }
    }
  }


  /* *********************************************************************
   * ******************* PRIVATE METHODS *********************************
   * ******************* used by Validator *******************************
   * *********************************************************************
   */

  /*
   * Examine a single line to see if it is a valid source
   * Adds line to array of valid or invalid sources
   * @param mixedCaseLine line to test (and report)
   * @return true if valid else false
   */
  isValidSource(mixedCaseLine) {
    let isValid = false;                          // assume guilty 

    // just ignore starting *
    if (mixedCaseLine.startsWith("*")) {
         mixedCaseLine = mixedCaseLine.substring(1);
    }
    mixedCaseLine = mixedCaseLine.trim();
    
    // perform tests on lower case line
    let line = mixedCaseLine.toLowerCase().trim();
   
    // ignore starting source:
    if ((line.length > 0) && (line.startsWith(Biography.SOURCE_START))) {
        line = line.substring(7);
        line = line.trim();
    }
    // ignore trailing .
    if (line.endsWith('.')) {
      line = line.slice(0, -1);
      line = line.trim();
    }
    // It takes a minimum number of characters to be valid
    if (line.length >= Biography.MIN_SOURCE_LEN) {

      if (!this.isInvalidStandAloneSource(line)) {
        line = line.trim();
        // FindAGrave citations may have partial strings that
        // would otherwise show up as invalid
        if (this.isFindAGraveCitation(line)) {
          isValid = true;
        } else {

          // Does line contain a phrase on the invalid partial source list?
          if (this.onAnyPartialSourceList(line)) {
            isValid = false;
          } else {
            // Check for line that starts with something on the invalid start partial list
            if (this.sourceRules.isInvalidStartPartialSource(line)) {
              isValid = false;
            } else {

              // TODO can you refactor so this uses a plugin architecture?

              // Some other things to check
              if (!this.isJustCensus(line)) {
                if (!this.invalidFamilyTree(line)) {
                  if (!this.isJustRepository(line)) {
                    if (!this.isJustGedcomCrud(line)) {
                      // TODO add more logic to eliminate sources as valid
                      // TODO is the manager's name a valid source (this is hard)
                      // TODO add logic to check for just the name followed by grave
                      isValid = true;
                    }
                  }
                }
              }
            }     // endif starts with invalid phrase
          }       // endif contains a phrase on invalid partial source list
        }         // endif a findagrave citation
      }           // endif on the list of invalid sources
    }             // endif too short when stripped of whitespace

    // Save line for reporting
    if (isValid) { 
      this.bioResults.sources.validSource.push(mixedCaseLine);
    } else {
      this.bioResults.sources.invalidSource.push(mixedCaseLine);
    }
    return isValid;
  }

  /*
   * Determine if valid standalone source
   * @param line input source string
   * @return true if on the standalone list of invalid sources
   */
  isInvalidStandAloneSource(line) {

    let isInvalidStandAloneSource = this.sourceRules.isInvalidSource(line);
    if (!isInvalidStandAloneSource && this.tooOldToRemember) {
        isInvalidStandAloneSource = this.sourceRules.isInvalidSourceTooOld(line);

      if ((this.isPre1700 || this.treatAsPre1700) && !isInvalidStandAloneSource) {
        isInvalidStandAloneSource = this.sourceRules.isInvalidSourcePre1700(line);
      }
      if (this.bioResults.isPre1500 && !isInvalidStandAloneSource) {
        // TODO add more pre1500 validation
      }
    }
    return isInvalidStandAloneSource;
  }

  /*
   * Determine if found on partial source list
   * @param line input source string
   * @return true if on a list of invalid partial sources else false
   */
  onAnyPartialSourceList(line) {

    let foundInvalidPartialSource = this.sourceRules.isInvalidPartialSource(line);
    if (this.tooOldToRemember && (!foundInvalidPartialSource)) {
      foundInvalidPartialSource = this.sourceRules.isInvalidPartialSourceTooOld(line);
      if ((this.isPre1700 || this.treatAsPre1700) && (!foundInvalidPartialSource)) {
        foundInvalidPartialSource = this.sourceRules.isInvalidPartialSourcePre1700(line);
      }
    }
    return foundInvalidPartialSource;
  }

  /* 
   * Validate content in <ref> tags
   * invalidSpanTargetList is used if line contains a span reference
   * @param refStrings array of string found within ref tag
   * @return true if at least one is valid else false
   */
  validateRefStrings(refStrings) {

    let isValid = false;                  // guilty until proven innnocent
    let line = "";
    let i = 0;
    while (i < refStrings.length) {
      line = refStrings[i];
      if (line.length > 0) {

        // Check span target if ref contains a span reference
        let startPos = line.indexOf(Biography.SPAN_REFERENCE_START);
        if (startPos >= 0) {
          startPos = startPos + 3;
          let endPos = line.indexOf("|");
          if (endPos < 0) {
            endPos = line.indexOf(Biography.SPAN_REFERENCE_END);
          }
          if ((endPos > 0) && (startPos < endPos)) {
            let spanId = line.substring(startPos, endPos);
            if (!this.invalidSpanTargetList.includes(spanId)) {
              isValid = true;
            }
          }
        } else {
          if (this.isValidSource(line)) {
            if (!isValid) {          // first one found?
              isValid = true;
            }
          }
        }
      }
      i++;
    }
    return isValid;
  }

  /* 
   * Validate all the strings after the == Sources heading
   * but before Acknowledgements or the end of the biography
   * @param isFullBio true if checking full bio else just a
   * string of sources
   * @return true if at lease one valid else false
   */
  validateReferenceStrings(isFullBio) {
    let isValid = false;
    let index = 0;
    if (isFullBio) {
      // start at the first of Sources or <references /> if neither, nothing to do
      // assume it is so messed up nothing to process
      index = this.sourcesIndex + 1;
      if (index <= 0) {
        index = this.referencesIndex + 1;
      }
      if (index <= 0) {
        index = this.bioLines.length;
      }
    }
    let lastIndex = this.bioLines.length;
    let line = "";
    let nextIndex = index + 1;
    while (index < lastIndex) {
      let mixedCaseLine = this.bioLines[index];
      line = mixedCaseLine.toLowerCase();
      // if line nothing but --- ignore it
      let tmpString = line.replaceAll('-', ' ');
      tmpString = tmpString.trim();
      if (tmpString.length <= 0) {
          line = tmpString;
      }
      nextIndex = index + 1;
      // Skip the <references line and any heading line or empty line
      // or the See Also line
      if ((!line.startsWith(Biography.REFERENCES_TAG)) &&
          (!line.startsWith(Biography.HEADING_START)) &&
          (!line.includes(Biography.SEE_ALSO)) &&
          (line.length > 0)) {

        // Now gather all lines from this line until an empty line
        // or a line that starts with * to test as the source
        let combinedLine = mixedCaseLine;
        let foundEndOfSource = false;
        while ((!foundEndOfSource) && (nextIndex < lastIndex)) {
          if (nextIndex < lastIndex) {
            // check next line
            let nextLine = this.bioLines[nextIndex];
            if (nextLine.length === 0) {
              foundEndOfSource = true;
            } else {
              if ((nextLine.startsWith("*")) || (nextLine.startsWith("--")) ||
                  (nextLine.startsWith("#")) ||
                  (nextLine.startsWith(Biography.REFERENCES_TAG)) ||
                  (nextLine.startsWith(Biography.HEADING_START))) {
                foundEndOfSource = true;
              } else {
                combinedLine = combinedLine + " " + nextLine;
                nextIndex++;
              }
            }
          }
        }
        mixedCaseLine = combinedLine;
        // At this point, the line should not contain an inline <ref
        // Unless all the ref are between Sources and references
        if ((line.indexOf("<ref") >= 0) && (index > this.referencesIndex)) {
          this.bioResults.style.bioHasStyleIssues = true;
          this.bioResults.style.bioHasRefAfterReferences = true;
        }
        // Only count misplaced line if there is a references tag
        if ((index < this.referencesIndex) && (this.referencesIndex > 0)) {
          this.bioResults.style.misplacedLineCount++;
        }
        let spanTargetStartPos = mixedCaseLine.indexOf(Biography.SPAN_TARGET_START);
        if (spanTargetStartPos < 0) {
          if (this.isValidSource(mixedCaseLine)) {
            if (!isValid) {
              isValid = true;       // first one found
            }
          }
        } else {
          if (this.isValidSpanTarget(mixedCaseLine)) {
            if (!isValid) {
              isValid = true;       // first one found
            }
          }
        }
      }
      index = nextIndex;
    }
    return isValid;
  }

  /*
   * Validate string that is a span target
   * Side effect: add to invalidSpanTargetList for invalid target
   * @param line line to be evaluated
   * @param startPos starting position in line
   * @return true if valid else false
   */
  isValidSpanTarget(mixedCaseLine) {
    let isValid = false;
    let spanTargetStartPos = mixedCaseLine.indexOf(Biography.SPAN_TARGET_START);
    let beforeSpan = mixedCaseLine.substring(0, spanTargetStartPos - 1);

    // extract target id found here <span id='ID'>
    let pos = mixedCaseLine.indexOf("=");
    pos++; // skip the =
    pos++; // skip the '
    let endPos = mixedCaseLine.indexOf("'", pos);
    let spanId = mixedCaseLine.substring(pos, endPos);

    // Process the line starting after the end of the span target
    // but it might have source or repository before the <span>
    pos = mixedCaseLine.indexOf(Biography.SPAN_TARGET_END);
    if (pos > 0) {
      pos = pos + Biography.SPAN_TARGET_END.length;
    } else {
      this.bioResults.style.bioHasStyleIssues = true;
      this.bioResults.style.bioHasSpanWithoutEndingSpan = true;
      pos = mixedCaseLine.length;
    }
    if (pos < mixedCaseLine.length) {
      // something after ending span
      mixedCaseLine = beforeSpan + " " + mixedCaseLine.substring(pos).trim();
      isValid = this.isValidSource(mixedCaseLine);
    }
    if (!isValid) {
        this.invalidSpanTargetList.push(spanId);
    }
    return isValid;
  }

  /*
   * Check for a line that is just
   * some collection of numbers and digits then census
   * @param line to check
   * @return true if just a census line else false
   */
  isJustCensus(line) {
    let isCensus = false;
    line = line.replace(/[^a-z ]/g, "");
    line = line.trim();
    if (this.sourceRules.isCensus(line)) {
      isCensus = true;
    } else {
      // get the census string portion of the line
      let theStr = this.sourceRules.hasCensusString(line);
      if (theStr.length > 0) {
        // lose census, at, on and everything not an alpha char
        line = line.replace(theStr, "");
        line = line.replace(/at/g, "");
        line = line.replace(/on/g, "");
        line = line.replace(/[^a-z]/g, "");
        line = line.trim();
        if (line.length === 0) {
          isCensus = true;
        } else {
          // lose things like ancestry, familysearch by themselves
          if (this.sourceRules.isInvalidSource(line)) {
            isCensus = true;
          }
        }
      }
    }
    if (isCensus) {
      return true;
    } else {
      return false;
    }
  }
  /*
   * Check for a line that contains both findagrave and created by
   * created by is an invalid partial source string UNLESS part of a findagrave
   * citation
   * @param line to test
   * @return true if line contains both findagrave and created by
   */
  isFindAGraveCitation(line) {
    if (((line.indexOf("findagrave")) >= 0) && 
        ((line.indexOf("created by")) >=0)) {
      return true;
    } else {
      return false;
    }
  }

  /*
   * Check for Ancestry Family Trees without a tree id 
   * or a tree id less than 4 characters, such as 0
   * @param line to test
   * @return true if Ancestry tree seems to have an id
   */
  invalidFamilyTree(line) {
    let isInvalidFamilyTree = false;
    let startPos = line.indexOf("ancestry family tree");
    if (startPos < 0) {
      startPos = line.indexOf("public member tree");
      if (startPos < 0) {
        startPos = line.indexOf("ancestry member family tree");
      }
      if (startPos < 0) {
        startPos = line.indexOf("{{ancestry tree");
      }
    }
    if (startPos >= 0) {
      line = line.substring(startPos);
      let hasId = false;
      let matches = line.match(/(\d+)/g);
      if (matches) {
        for (let i = 0; i < matches.length; i++) {
          if (matches[i].length > 4) {
            hasId = true;
          }
        }
      }
      if (!hasId) {
        isInvalidFamilyTree = true;
      }
    }
    return isInvalidFamilyTree;
  }

  /*
   * Check for just a repository
   * @param line to test
   * @return true if this is just a repository line
   */
  isJustRepository(line) {
    let isRepository = false;
    if (line.includes("repository")) {
      let repositoryStrings = [
        "ancestry",
        "com",
        "name",
        "address",
        "http",
        "www",
        "the church of jesus christ of latter-day saints",
        "note",
        "family history library",
        "n west temple street",
        "salt lake city",
        "utah",
        "usa",
        "360 west 4800 north",
        "provo",
        "ut",
        "city",
        "country", 
        "not given",
        "e-mail",
        "phone number",
        "internet",
        "cont",
        "unknown",
      ];
      for (let i = 0; i < repositoryStrings.length; i++) {
        let str = repositoryStrings[i];
        line = line.replaceAll(str, "");
      }
      line = line.replace(/r-/g, "");
      line = line.replace(/#r/g, "");
      line = line.replace(/[^a-z]/g, "");
      line = line.trim();
      if (line.length > 0) {
        if (line === "repository") {
          isRepository = true;
        }
      }
    }
    return isRepository;
  }

  /*
   * check for GEDCOM crud see Suggestion 853
   * in most cases this is in the Bio not sources, 
   * so you don't see it
   * @param line line to test
   * @return true if line contains GEDCOM crud and nothing else
   */
  isJustGedcomCrud(line) {
    let isGedcomCrud = false;
    let crudStrings = [
      "user id",
      "data changed",
      "lds endowment",
      "lds baptism",
      "record file number",
      "submitter",
      "object",
      "color",
      "upd",
      "ppexclude",
    ];
    if (line.startsWith(":")) {
      line = line.substring(1);
    }
    line = line.trim();
    let i = 0;
    while ((i < crudStrings.length) && (!isGedcomCrud)) {
      if (line.startsWith(crudStrings[i])) {
        isGedcomCrud = true;
      }
      i++;
    }
    return isGedcomCrud;
  }

}
